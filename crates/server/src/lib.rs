//! # crate-peek-server
use rmcp::{
    ErrorData as McpError, RoleServer, ServerHandler,
    handler::server::router::{prompt::PromptRouter, tool::ToolRouter},
    model::{
        AnnotateAble, CallToolResult, Content, GetPromptRequestParam, GetPromptResult,
        Implementation, InitializeRequestParam, InitializeResult, ListPromptsResult,
        ListResourceTemplatesResult, PaginatedRequestParam, ProtocolVersion, RawResource,
        ReadResourceRequestParam, ReadResourceResult, Resource, ResourceContents,
        ServerCapabilities, ServerInfo,
    },
    prompt_handler, prompt_router,
    service::RequestContext,
    tool, tool_handler, tool_router,
};
use serde_json::json;

/// Structure for containing the routes for the server
#[derive(Clone)]
pub struct CratePeek {
    /// MCP tools registry (generated by `#[tool_router]`)
    tool_router: ToolRouter<Self>,
    prompt_router: PromptRouter<Self>,
}

/// Implementation of the `CratePeek` structure
#[tool_router]
impl CratePeek {
    /// creates a new instance of the routes for the server
    #[must_use]
    pub fn new() -> Self {
        Self { tool_router: Self::tool_router(), prompt_router: Self::prompt_router() }
    }

    fn create_resource_text(uri: &str, name: &str) -> Resource {
        RawResource::new(uri, name.to_string()).no_annotation()
    }

    #[allow(clippy::unused_self, clippy::unnecessary_wraps)]
    #[tool(description = "Get the documentation for specified crate")]
    fn crate_doc(&self) -> Result<CallToolResult, McpError> {
        Ok(CallToolResult::success(vec![Content::text("TODO: finish this tool!".to_string())]))
    }
}

impl Default for CratePeek {
    fn default() -> Self {
        Self::new()
    }
}

#[prompt_router]
impl CratePeek {}

#[tool_handler]
#[prompt_handler]
impl ServerHandler for CratePeek {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            protocol_version: ProtocolVersion::V_2024_11_05,
            capabilities: ServerCapabilities::builder()
                .enable_prompts()
                .enable_resources()
                .enable_tools()
                .build(),
            server_info: Implementation::from_build_env(),
            instructions: Some(
                "This MCP server indexes Rust project crates, extracts their documentation, and \
                 exposes that knowledge to the LLM for enhanced code understanding. Tools provide \
                 project-aware crate discovery, documentation generation, and retrieval. No user \
                 prompts â€” the LLM calls tools automatically to stay informed about your codebase."
                    .to_string(),
            ),
        }
    }

    async fn read_resource(
        &self,
        ReadResourceRequestParam { uri }: ReadResourceRequestParam,
        _: RequestContext<RoleServer>,
    ) -> Result<ReadResourceResult, McpError> {
        match uri.as_str() {
            "str:////Users/to/some/path/" => {
                let cwd = "/Users/to/some/path/";
                Ok(ReadResourceResult { contents: vec![ResourceContents::text(cwd, uri)] })
            }
            "memo://insights" => {
                let memo = "Business Intelligence Memo\n\nAnalysis has revealed 5 key insights ...";
                Ok(ReadResourceResult { contents: vec![ResourceContents::text(memo, uri)] })
            }
            _ => {
                Err(McpError::resource_not_found(
                    "resource_not_found",
                    Some(json!({
                        "uri": uri
                    })),
                ))
            }
        }
    }

    async fn list_resource_templates(
        &self,
        _request: Option<PaginatedRequestParam>,
        _: RequestContext<RoleServer>,
    ) -> Result<ListResourceTemplatesResult, McpError> {
        Ok(ListResourceTemplatesResult { next_cursor: None, resource_templates: Vec::new() })
    }

    async fn initialize(
        &self,
        _request: InitializeRequestParam,
        _context: RequestContext<RoleServer>,
    ) -> Result<InitializeResult, McpError> {
        Ok(self.get_info())
    }

    fn ping(
        &self,
        context: RequestContext<RoleServer>,
    ) -> impl Future<Output = Result<(), McpError>> + Send + '_ {
        std::future::ready(Ok(()))
    }

    fn complete(
        &self,
        request: rmcp::model::CompleteRequestParam,
        context: RequestContext<RoleServer>,
    ) -> impl Future<Output = Result<rmcp::model::CompleteResult, McpError>> + Send + '_ {
        std::future::ready(Ok(rmcp::model::CompleteResult::default()))
    }

    fn set_level(
        &self,
        request: rmcp::model::SetLevelRequestParam,
        context: RequestContext<RoleServer>,
    ) -> impl Future<Output = Result<(), McpError>> + Send + '_ {
        std::future::ready(Err(McpError::method_not_found::<rmcp::model::SetLevelRequestMethod>()))
    }

    fn list_resources(
        &self,
        request: Option<rmcp::model::PaginatedRequestParam>,
        context: RequestContext<RoleServer>,
    ) -> impl Future<Output = Result<rmcp::model::ListResourcesResult, McpError>> + Send + '_ {
        std::future::ready(Ok(rmcp::model::ListResourcesResult::default()))
    }

    fn subscribe(
        &self,
        request: rmcp::model::SubscribeRequestParam,
        context: RequestContext<RoleServer>,
    ) -> impl Future<Output = Result<(), McpError>> + Send + '_ {
        std::future::ready(Err(McpError::method_not_found::<rmcp::model::SubscribeRequestMethod>()))
    }

    fn unsubscribe(
        &self,
        request: rmcp::model::UnsubscribeRequestParam,
        context: RequestContext<RoleServer>,
    ) -> impl Future<Output = Result<(), McpError>> + Send + '_ {
        std::future::ready(Err(
            McpError::method_not_found::<rmcp::model::UnsubscribeRequestMethod>(),
        ))
    }

    fn on_cancelled(
        &self,
        notification: rmcp::model::CancelledNotificationParam,
        context: rmcp::service::NotificationContext<RoleServer>,
    ) -> impl Future<Output = ()> + Send + '_ {
        std::future::ready(())
    }

    fn on_progress(
        &self,
        notification: rmcp::model::ProgressNotificationParam,
        context: rmcp::service::NotificationContext<RoleServer>,
    ) -> impl Future<Output = ()> + Send + '_ {
        std::future::ready(())
    }

    fn on_initialized(
        &self,
        context: rmcp::service::NotificationContext<RoleServer>,
    ) -> impl Future<Output = ()> + Send + '_ {
        tracing::info!("client initialized");
        std::future::ready(())
    }

    fn on_roots_list_changed(
        &self,
        context: rmcp::service::NotificationContext<RoleServer>,
    ) -> impl Future<Output = ()> + Send + '_ {
        std::future::ready(())
    }
}
